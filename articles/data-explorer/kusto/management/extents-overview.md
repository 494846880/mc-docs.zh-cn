---
title: 盘区（数据分片）- Azure 数据资源管理器
description: 本文介绍 Azure 数据资源管理器中的盘区（数据分片）。
services: data-explorer
author: orspod
ms.author: v-tawe
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
origin.date: 03/13/2020
ms.date: 10/29/2020
ms.openlocfilehash: 7c4ea53b22b2139cda398a8e9b733098490d7086
ms.sourcegitcommit: 93309cd649b17b3312b3b52cd9ad1de6f3542beb
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/30/2020
ms.locfileid: "93104132"
---
# <a name="extents-data-shards"></a>盘区（数据分片）

## <a name="overview"></a>概述

Kusto 可以支持含有大量记录（行）和大量数据的表。 为了处理此类大型表，每个表的数据被划分为较小的“块”，称为数据分片或盘区（这两个术语是同义词） 。 表的所有盘区的并集保存表的数据。 单个盘区将保持小于单个节点的容量，并且盘区分散在群集的节点上，从而实现横向扩展。

盘区就像一种小型表。 它包含数据和元数据，以及其创建时间和与其数据关联的可选标记等信息。 此外，盘区通常保存能让 Kusto 高效查询数据的信息。
例如盘区中每列数据的索引和编码字典（如果已对列数据进行编码）。 因此，表的数据是表的盘区中所有数据的并集。

盘区是不可变的，并且永远不能修改。 只能查询它、将它重新分配给另一个节点或从表中删除它。 可通过以下方式进行数据修改：创建一个或多个新盘区，并将旧盘区与新盘区进行事务交换。

盘区保存物理上按列排列的记录的集合。
此方法称为分栏式存储。 利用它可以高效地对数据进行编码和压缩，因为同一列中的不同值经常彼此类似。 它还支持更高效地查询大量数据，因为只需加载查询所使用的列。 在内部，盘区内的每个数据列将细分为若干个段，段分为若干个块。 这种分隔对查询而言并不能观察到，这可使 Kusto 优化列压缩和索引编制。

为了保持查询效率，较小的盘区将合并到较大的盘区中。
根据配置的[合并策略](mergepolicy.md)和[分片策略](shardingpolicy.md)，合并作为后台过程自动完成。
合并盘区可减少跟踪大量盘区带来的管理开销。更重要的是，它可使 Kusto 优化其索引并改进压缩。

某个盘区达到特定限制（如大小）后，盘区合并将停止，因为超过特定点后，合并非但不会提高效率，反而会降低效率。

在表上定义[数据分区策略](partitioningpolicy.md)时，盘区在创建后将经历另一个后台过程（后期引入）。 此过程重新引入源盘区中的数据，并创建“同类”盘区，其中作为表的“分区键”的列的值全部属于同一分区。 如果策略包括“哈希分区键”，属于同一分区的所有同类盘区将被分配到群集中的同一数据节点。

> [!NOTE]
> 盘区级别的操作（如合并或更改盘区标记）不会修改现有盘区。
> 而是基于现有源盘区在这些操作中创建新的盘区。 新的盘区将在单个事务中替换其前身。

常见的盘区生命周期：

1. 盘区由“引入”操作创建。
1. 盘区与其他盘区合并。 如果要合并的盘区较小，Kusto 实际上会对其执行引入过程，称为“重新生成”。 在盘区达到一定大小后，只对索引执行合并。 不会修改存储中盘区的数据项目。
1. 由于保留策略的原因，合并的盘区（该盘区的世系可能追溯到其他合并的盘区）最终会被删除。 
   删除盘区时，根据时间（旧的盘区 x 小时/天），在计算中使用合并盘区中最新盘区的创建日期。

## <a name="extent-creation-time"></a>盘区创建时间

对于每个盘区而言，创建时间是关键信息之一。 此时间用于：

1. 保留 - 较早创建的盘区将较早被删除。
1. 缓存 - 最近创建的盘区将保存在[热缓存](cachepolicy.md)
1. 采样 - 使用查询操作（例如 `take`）时，建议使用最近的盘区

事实上，Kusto 会跟踪每个区的两个 `datetime` 值：`MinCreatedOn` 和 `MaxCreatedOn`。
最初，这两个值是相同的。 如果该盘区与其他盘区合并，则新值将与合并盘区的原始最小值和最大值保持一致。

通常，会根据引入盘区中的数据的时间来设置盘区的创建时间。 客户端可以选择覆盖该盘区的创建时间，方法是在 [ingestion 属性](../../ingestion-properties.md)中提供备用创建时间。
如果出于保留目的，客户端想要重新引入数据并且不希望它看起来像“迟到”的数据，则覆盖很有用。

## <a name="extent-tagging"></a>盘区标记

Kusto 支持将多个可选盘区标记附加到盘区，作为其元数据的一部分。 盘区标记（或只是标记）是与盘区关联的字符串。 可以使用 [.show extents](./show-extents.md) 命令查看与某个盘区关联的标记，并使用 [extent-tags()](../query/extenttagsfunction.md) 函数查看与某个盘区内的记录相关联的标记。
盘区标记可用于高效地描述盘区内的所有数据所共有的属性。
例如，可以在引入期间添加盘区标记，指示引入数据的源，并在稍后使用该标记。 因为盘区描述数据，因此当两个或多个盘区合并时，它们的相关标记也将合并。 生成的盘区的标记将是这些合并盘区的所有标记的并集。

Kusto 向所有其值具有格式“前缀 后缀” 的盘区标记分配特殊含义，其中“前缀”是以下项之一：

* `drop-by:`
* `ingest-by:`

### <a name="drop-by-extent-tags"></a>'drop-by:' 盘区标记

以 `drop-by:` 前缀开头的标记可用于控制要合并的其他盘区。 具有给定 `drop-by:` 标记的盘区可以合并在一起，但不会与其他盘区合并。 然后，可以根据其 `drop-by:` 标记发出命令以删除盘区。

例如：

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

#### <a name="performance-notes"></a>性能说明

* 不要滥用 `drop-by` 标记。 以上述方式删除数据仅适用于很少发生的事件。 它不用于替换记录级数据，并且要求以这种方式标记的数据很庞大。 如果尝试为每个记录或少量记录提供不同的标记，可能会对性能产生严重影响。
* 如果引入数据后，在一段时间内不需要 `drop-by` 标记，建议[删除标记](#drop-by-extent-tags)。

### <a name="ingest-by-extent-tags"></a>'ingest-by:' 盘区标记

以 `ingest-by:` 前缀开头的标记可用于确保数据仅引入一次。 如果已存在具有此特定 `ingest-by:` 标记的盘区，则可以发出 **`ingestIfNotExists`** 属性命令阻止数据引入。
`tags` 和 `ingestIfNotExists` 的值都是字符串数组，序列化为 JSON。

以下示例仅引入数据一次。 第二个和第三个命令不执行任何操作：

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> 通常，引入命令可能同时包含 `ingest-by:` 标记和 `ingestIfNotExists` 属性，并设置为相同的值，如上述第三个命令中所示。

#### <a name="performance-notes"></a>性能说明

* 不建议过度使用 `ingest-by` 标记。
如果已知馈送 Kusto 的管道有数据重复，我们建议在将数据引入 Kusto 之前，尽可能解决这些重复项。 此外，仅当引入到 Kusto 的部分可能会自行引入重复项时（例如，有一种重试机制可能会与正在进行的引入调用重叠），才在 Kusto 中使用 `ingest-by` 标记。 尝试为每个引入调用设置唯一的 `ingest-by` 标记可能会对性能产生严重影响。
* 如果在数据引入后的某个时间段内不需要此类标记，则建议[删除区标记](drop-extent-tags.md)。
